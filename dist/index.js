var N=Object.create;var b=Object.defineProperty;var P=Object.getOwnPropertyDescriptor;var R=Object.getOwnPropertyNames;var F=Object.getPrototypeOf,K=Object.prototype.hasOwnProperty;var V=(e,t)=>{for(var i in t)b(e,i,{get:t[i],enumerable:!0})},I=(e,t,i,s)=>{if(t&&typeof t=="object"||typeof t=="function")for(let n of R(t))!K.call(e,n)&&n!==i&&b(e,n,{get:()=>t[n],enumerable:!(s=P(t,n))||s.enumerable});return e};var d=(e,t,i)=>(i=e!=null?N(F(e)):{},I(t||!e||!e.__esModule?b(i,"default",{value:e,enumerable:!0}):i,e)),L=e=>I(b({},"__esModule",{value:!0}),e);var U={};V(U,{BLOCK_SUBSIDY:()=>p,Block:()=>a,Blockchain:()=>T,COINBASE_TX:()=>c,CoinbaseTransaction:()=>f,GENESIS_BLOCK_DATA:()=>o,GenesisBlock:()=>y,INITIAL_DIFFICULTY:()=>k,Mempool:()=>w,NUM_OF_BLOCKS_TO_HALF_MINING_REWARD:()=>g,TARGET_MINE_RATE_MS:()=>u,Transaction:()=>h,Wallet:()=>l,getSHA256Hash:()=>m});module.exports=L(U);var _=d(require("hex-to-binary"));var H=d(require("dotenv"));H.config();var u=100,k=3,p=50,g=21e4,o={timestamp:1,previousHash:null,difficulty:k,nonce:0,height:0,transactions:[]},c={fromAddress:process.env.COINBASE_TX_FROM_ADDRESS,secretKey:process.env.COINBASE_TX_SECRET_KEY,memo:"Coinbase Tx"};var D=require("uuid"),x=d(require("elliptic"));var E=d(require("crypto")),W=(...e)=>{let i=e.map(s=>JSON.stringify(s)).sort().join();return E.createHash("sha256").update(i).digest("hex")},m=W;var M=new x.default.ec("secp256k1"),h=class{fromAddress;toAddress;amount;memo;fee;uuid;timestamp;signature;__type;constructor(t,i,s,n,r=0){this.fromAddress=t,this.toAddress=i,this.amount=s,this.memo=n,this.fee=r,this.uuid=(0,D.v4)(),this.timestamp=Date.now(),this.__type="default"}calculateHash(){return m(this.fromAddress,this.toAddress,this.amount,this.memo,this.fee,this.uuid,this.timestamp)}signTransaction(t){let i=M.keyFromPrivate(t,"hex");if(i.getPublic("hex")!==this.fromAddress)throw new Error("Unauthorized: Your private key is invalid or doesn't match your public address");let s=this.calculateHash(),n=i.sign(s,"base64");this.signature=n.toDER("hex")}hasValidSignature(){return this.signature?M.keyFromPublic(this.fromAddress,"hex").verify(this.calculateHash(),this.signature):!1}hasRequiredFields(){return!!(this.fromAddress&&this.toAddress&&this.amount>0)}isValid(){return this.hasRequiredFields()&&this.hasValidSignature()&&this.amount>0&&this.fee>=0}};var A=class extends h{constructor(t,i){super(c.fromAddress,t,i,c.memo),this.__type="CoinbaseTransaction",this.signTransaction(c.secretKey)}isValid(){let{fromAddress:t,memo:i}=c;return this.fromAddress===t&&this.memo===i&&this.amount>0&&this.hasValidSignature()}},f=A;var C=class{transactions;previousHash;height;difficulty;nonce;timestamp;miningDurationMs;hash;__type;constructor(t,i,s="",n){this.transactions=t,this.previousHash=s,this.height=n,this.difficulty=i,this.nonce=0,this.timestamp=Date.now(),this.__type="default"}mineBlock(){let t=Date.now();this.hash=this.getProofOfWorkHash();let i=Date.now();return this.miningDurationMs=i-t,this.miningDurationMs}getProofOfWorkHash(){let t="",i="0".repeat(this.difficulty);for(;(0,_.default)(t).substring(0,this.difficulty)!==i;)this.nonce++,t=this.calculateHash();return t}calculateHash(){return m(this.timestamp,this.transactions,this.previousHash,this.height,this.difficulty,this.nonce)}isValid(){return this.hasValidTransactions()&&this.hasOnlyOneCoinbaseTx()&&this.timestampIsInPast()&&this.hasProofOfWork()}hasValidTransactions(){return this.transactions.every(t=>t.isValid())}hasOnlyOneCoinbaseTx(){return this.transactions.filter(i=>i instanceof f).length===1}timestampIsInPast(){return this.timestamp?this.timestamp<Date.now()+1e3*5:!1}hasProofOfWork(){return this.hasValidHash()&&this.firstDCharsAreZero()}hasValidHash(){return this.hash===this.calculateHash()}firstDCharsAreZero(){let t="0".repeat(this.difficulty);return(0,_.default)(this.hash).substring(0,this.difficulty)===t}static areBlocksValidlyConnected(t,i){return this.blocksHashesAreConnected(t,i)&&this.block2ComesAfterBlock1(t,i)&&this.difficultyJumpIsValid(t,i)&&this.block1HasPlausibleMiningDuration(t,i)}static blocksHashesAreConnected(t,i){return i.previousHash===t.hash}static block2ComesAfterBlock1(t,i){let s=i.timestamp-t.timestamp,n=-1e3*60*10;return s>n}static difficultyJumpIsValid(t,i){return i.difficulty-t.difficulty<-1?!1:t.miningDurationMs<u?i.difficulty>=t.difficulty+1:!0}static block1HasPlausibleMiningDuration(t,i){let n=i.timestamp-t.timestamp;return t.miningDurationMs<n+12e4}},a=C;var O=class extends a{constructor(){super(o.transactions,o.difficulty,o.previousHash,o.height),this.__type="GenesisBlock",this.mineBlock()}isValid(){let{difficulty:t,transactions:i,previousHash:s,height:n}=o;return this.hasProofOfWork()&&this.timestampIsInPast()&&this.difficulty===t&&this.transactions.length===i.length&&this.previousHash===s&&this.height===n}},y=O;var T=class{chain;constructor(){this.chain=[new y]}getLatestBlock(){return this.chain[this.chain.length-1]}addBlockToChain(t){return this.chain.push(t),this.chain}isChainValid(){if(!this.chain[0].isValid())return!1;for(let t=1;t<this.chain.length;t++){let i=this.chain[t-1],s=this.chain[t];if(!s.isValid()||!a.areBlocksValidlyConnected(i,s))return!1}return!0}replaceChain(t){return t.chain.length<=this.chain.length||!t.isChainValid()?!1:(this.chain=t.chain,!0)}};var v=d(require("elliptic")),G=new v.default.ec("secp256k1"),l=class{publicKey;privateKey;constructor(){let t=G.genKeyPair();this.publicKey=t.getPublic("hex"),this.privateKey=t.getPrivate("hex")}getPublicKey(){return this.publicKey}getPrivateKey(){return this.privateKey}static getTotalPendingOwedByWallet(t,i){return i.filter(r=>r.fromAddress===t).map(r=>r.amount+r.fee).reduce((r,B)=>r+B,0)}static walletHasSufficientFunds(t,i,s,n){let r=this.getBalanceOfAddress(t,s);if(r===null)return!1;let B=this.getTotalPendingOwedByWallet(t,n);return r>=B+i.amount+i.fee}static getAllTransactionsForWallet(t,i){let s=[];for(let n of i)for(let r of n.transactions)(r.fromAddress===t||r.toAddress===t)&&s.push(r);return s}static getBalanceOfAddress(t,i){let s=0;for(let n of i)for(let r of n.transactions)r.fromAddress===t&&(s-=r.amount,s-=r.fee),r.toAddress===t&&(s+=r.amount);return s}};var S=class{pendingTransactions;blockchain;constructor(t){this.pendingTransactions=[],this.blockchain=t}getCurrentBlockSubsidy(){let t=this.blockchain.chain.length;if(t<g)return p;{let i=t/g,s=p;for(let n=0;n<i;n++)s/=2;return s}}addTransaction(t){if(!t.isValid())throw new Error("Cannot add invalid transaction to chain");if(!l.walletHasSufficientFunds(t.fromAddress,t,this.blockchain.chain,this.pendingTransactions))throw new Error("not enough funds for transactions in mempool or this transaction itself");if(this.pendingTransactions.some(i=>i.signature===t.signature))throw new Error("Transaction already in mempool");this.pendingTransactions.push(t)}addCoinbaseTxToMempool(t){let i=new f(t,this.getMiningReward());return this.pendingTransactions.push(i),this.pendingTransactions}getTotalTransactionFees(){return this.pendingTransactions.map(t=>t.fee).reduce((t,i)=>t+i,0)}getMiningReward(){return this.getTotalTransactionFees()+this.getCurrentBlockSubsidy()}addPendingTransactionsToBlock(){return new a(this.pendingTransactions,this.getNewMiningDifficulty(),this.blockchain.getLatestBlock().hash,this.blockchain.chain.length)}getNewMiningDifficulty(){let t=this.blockchain.getLatestBlock().miningDurationMs,i=this.blockchain.getLatestBlock().difficulty;return t<u?i++:i>1&&i--,i}minePendingTransactions(t){this.addCoinbaseTxToMempool(t);let i=this.addPendingTransactionsToBlock();return i.mineBlock(),this.blockchain.addBlockToChain(i),this.resetMempool(),i}resetMempool(){this.pendingTransactions=[]}},w=S;0&&(module.exports={BLOCK_SUBSIDY,Block,Blockchain,COINBASE_TX,CoinbaseTransaction,GENESIS_BLOCK_DATA,GenesisBlock,INITIAL_DIFFICULTY,Mempool,NUM_OF_BLOCKS_TO_HALF_MINING_REWARD,TARGET_MINE_RATE_MS,Transaction,Wallet,getSHA256Hash});
